# A0142418L
###### \java\seedu\taskmanager\commons\core\Config.java
``` java
    public void setTaskManagerFilePath(String taskManagerFilePath) throws DuplicateTaskManagerFilePathException {
        if (this.taskManagerFilePath.equals(taskManagerFilePath)) {
            throw new DuplicateTaskManagerFilePathException();
        } else {
            this.taskManagerFilePath = taskManagerFilePath;
        }
    }
    
```
###### \java\seedu\taskmanager\commons\core\Config.java
``` java
    /**
     * Signals that the file path specified is the same as the current one.
     */
    public static class DuplicateTaskManagerFilePathException extends DuplicateDataException {
        protected DuplicateTaskManagerFilePathException() {
            super("Operation would result in duplicate tasks");
        }
    }
    
```
###### \java\seedu\taskmanager\commons\util\CurrentDate.java
``` java
public class CurrentDate {

    public static final String MESSAGE_DAY_CONSTRAINTS = "Task date should be either "
            + "a day (e.g. thursday) or a date with the format: DD/MM/YY (e.g. 03/03/17)\n"
            + "May also include time (e.g. 1400) behind date \n"
            + "Enter HELP for user guide with detailed explanations of all commands";

    public static final String CURRENTDATE_VALIDATION_REGEX_TODAY1 = "Today";
    public static final String CURRENTDATE_VALIDATION_REGEX_TODAY2 = "today";
    public static final String CURRENTDATE_VALIDATION_REGEX_TOMORROW1 = "Tomorrow";
    public static final String CURRENTDATE_VALIDATION_REGEX_TOMORROW2 = "tomorrow";
    public static final String CURRENTDATE_VALIDATION_REGEX_TOMORROW3 = "Tmr";
    public static final String CURRENTDATE_VALIDATION_REGEX_TOMORROW4 = "tmr";
    public static final String CURRENTDATE_VALIDATION_REGEX_MONDAY1 = "Monday";
    public static final String CURRENTDATE_VALIDATION_REGEX_MONDAY2 = "monday";
    public static final String CURRENTDATE_VALIDATION_REGEX_MONDAY3 = "Mon";
    public static final String CURRENTDATE_VALIDATION_REGEX_MONDAY4 = "mon";
    public static final String CURRENTDATE_VALIDATION_REGEX_TUESDAY1 = "Tuesday";
    public static final String CURRENTDATE_VALIDATION_REGEX_TUESDAY2 = "tuesday";
    public static final String CURRENTDATE_VALIDATION_REGEX_TUESDAY3 = "Tues";
    public static final String CURRENTDATE_VALIDATION_REGEX_TUESDAY4 = "tues";
    public static final String CURRENTDATE_VALIDATION_REGEX_WEDNESDAY1 = "Wednesday";
    public static final String CURRENTDATE_VALIDATION_REGEX_WEDNESDAY2 = "wednesday";
    public static final String CURRENTDATE_VALIDATION_REGEX_WEDNESDAY3 = "Wed";
    public static final String CURRENTDATE_VALIDATION_REGEX_WEDNESDAY4 = "wed";
    public static final String CURRENTDATE_VALIDATION_REGEX_THURSDAY1 = "Thursday";
    public static final String CURRENTDATE_VALIDATION_REGEX_THURSDAY2 = "thursday";
    public static final String CURRENTDATE_VALIDATION_REGEX_THURSDAY3 = "Thurs";
    public static final String CURRENTDATE_VALIDATION_REGEX_THURSDAY4 = "thurs";
    public static final String CURRENTDATE_VALIDATION_REGEX_FRIDAY1 = "Friday";
    public static final String CURRENTDATE_VALIDATION_REGEX_FRIDAY2 = "friday";
    public static final String CURRENTDATE_VALIDATION_REGEX_FRIDAY3 = "Fri";
    public static final String CURRENTDATE_VALIDATION_REGEX_FRIDAY4 = "fri";
    public static final String CURRENTDATE_VALIDATION_REGEX_SATURDAY1 = "Saturday";
    public static final String CURRENTDATE_VALIDATION_REGEX_SATURDAY2 = "saturday";
    public static final String CURRENTDATE_VALIDATION_REGEX_SATURDAY3 = "Sat";
    public static final String CURRENTDATE_VALIDATION_REGEX_SATURDAY4 = "sat";
    public static final String CURRENTDATE_VALIDATION_REGEX_SUNDAY1 = "Sunday";
    public static final String CURRENTDATE_VALIDATION_REGEX_SUNDAY2 = "sunday";
    public static final String CURRENTDATE_VALIDATION_REGEX_SUNDAY3 = "Sun";
    public static final String CURRENTDATE_VALIDATION_REGEX_SUNDAY4 = "sun";

    public static int currentDay;
    public static String currentDate = "";

    public CurrentDate() {
        currentDay = getCurrentDay();
        currentDate = getCurrentDate();
    }

    /**
     * Checks to see if user has input a valid day, this function includes
     * different spellings of the same day
     */
    public static boolean isValidDay(String test) {
        return test.matches(CURRENTDATE_VALIDATION_REGEX_MONDAY1) || test.matches(CURRENTDATE_VALIDATION_REGEX_MONDAY2)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_MONDAY3)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_MONDAY4)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_TUESDAY1)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_TUESDAY2)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_TUESDAY3)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_TUESDAY4)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_WEDNESDAY1)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_WEDNESDAY2)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_WEDNESDAY3)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_WEDNESDAY4)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_THURSDAY1)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_THURSDAY2)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_THURSDAY3)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_THURSDAY4)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_FRIDAY1)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_FRIDAY2)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_FRIDAY3)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_FRIDAY4)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_SATURDAY1)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_SATURDAY2)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_SATURDAY3)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_SATURDAY4)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_SUNDAY1)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_SUNDAY2)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_SUNDAY3)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_SUNDAY4)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_TODAY1)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_TODAY2)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_TOMORROW1)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_TOMORROW2)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_TOMORROW3)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_TOMORROW4);
    }

    /**
     * @return Day number relative to the day itself (e.g. Sunday == 1 &
     *         Wednesday == 4)
     */
    public static int getNewDay(String day) {

        if (day.matches(CURRENTDATE_VALIDATION_REGEX_SUNDAY1) || day.matches(CURRENTDATE_VALIDATION_REGEX_SUNDAY2)
                || day.matches(CURRENTDATE_VALIDATION_REGEX_SUNDAY3)
                || day.matches(CURRENTDATE_VALIDATION_REGEX_SUNDAY4)) {
            return 1;
        } else {
            if (day.matches(CURRENTDATE_VALIDATION_REGEX_MONDAY1) || day.matches(CURRENTDATE_VALIDATION_REGEX_MONDAY2)
                    || day.matches(CURRENTDATE_VALIDATION_REGEX_MONDAY3)
                    || day.matches(CURRENTDATE_VALIDATION_REGEX_MONDAY4)) {
                return 2;
            } else {
                if (day.matches(CURRENTDATE_VALIDATION_REGEX_TUESDAY1)
                        || day.matches(CURRENTDATE_VALIDATION_REGEX_TUESDAY2)
                        || day.matches(CURRENTDATE_VALIDATION_REGEX_TUESDAY3)
                        || day.matches(CURRENTDATE_VALIDATION_REGEX_TUESDAY4)) {
                    return 3;
                } else {
                    if (day.matches(CURRENTDATE_VALIDATION_REGEX_WEDNESDAY1)
                            || day.matches(CURRENTDATE_VALIDATION_REGEX_WEDNESDAY2)
                            || day.matches(CURRENTDATE_VALIDATION_REGEX_WEDNESDAY3)
                            || day.matches(CURRENTDATE_VALIDATION_REGEX_WEDNESDAY4)) {
                        return 4;
                    } else {
                        if (day.matches(CURRENTDATE_VALIDATION_REGEX_THURSDAY1)
                                || day.matches(CURRENTDATE_VALIDATION_REGEX_THURSDAY2)
                                || day.matches(CURRENTDATE_VALIDATION_REGEX_THURSDAY3)
                                || day.matches(CURRENTDATE_VALIDATION_REGEX_THURSDAY4)) {
                            return 5;
                        } else {
                            if (day.matches(CURRENTDATE_VALIDATION_REGEX_FRIDAY1)
                                    || day.matches(CURRENTDATE_VALIDATION_REGEX_FRIDAY2)
                                    || day.matches(CURRENTDATE_VALIDATION_REGEX_FRIDAY3)
                                    || day.matches(CURRENTDATE_VALIDATION_REGEX_FRIDAY4)) {
                                return 6;
                            } else {
                                if (day.matches(CURRENTDATE_VALIDATION_REGEX_SATURDAY1)
                                        || day.matches(CURRENTDATE_VALIDATION_REGEX_SATURDAY2)
                                        || day.matches(CURRENTDATE_VALIDATION_REGEX_SATURDAY3)
                                        || day.matches(CURRENTDATE_VALIDATION_REGEX_SATURDAY4)) {
                                    return 7;
                                } else {
                                    if (day.matches(CURRENTDATE_VALIDATION_REGEX_TODAY1)
                                            || day.matches(CURRENTDATE_VALIDATION_REGEX_TODAY2)) {
                                        Calendar calendar = Calendar.getInstance(TimeZone.getDefault());
                                        int dayOfWeek = calendar.get(Calendar.DAY_OF_WEEK);

                                        return dayOfWeek;
                                    } else {
                                        Calendar calendar = Calendar.getInstance(TimeZone.getDefault());
                                        int dayOfWeek = calendar.get(Calendar.DAY_OF_WEEK);

                                        if (dayOfWeek + 1 == 8) {
                                            return dayOfWeek = 1;
                                        } else {
                                            return dayOfWeek + 1;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    /**
     * @return Current Day with respect to the date on the computer
     */
    public static int getCurrentDay() {
        Calendar calendar = Calendar.getInstance(TimeZone.getDefault());
        int day = calendar.get(Calendar.DATE);
        return day;
    }

    /**
     * @return Current Date with respect to the date on the computer
     */
    public static String getCurrentDate() {
        String newdate = "";
        String stringDay = "";
        String stringMonth = "";
        String stringYear = "";

        Calendar calendar = Calendar.getInstance(TimeZone.getDefault());
        // getTime() returns the current date in default time zone
        int day = calendar.get(Calendar.DATE);
        // Note: +1 the month for current month
        int month = calendar.get(Calendar.MONTH) + 1;
        int year = calendar.get(Calendar.YEAR);

        if (day < 10) {
            stringDay = "0" + Integer.toString(day);
        } else {
            stringDay = Integer.toString(day);
        }
        if (month < 10) {
            stringMonth = "0" + Integer.toString(month);
        } else {
            stringMonth = Integer.toString(month);
        }
        stringYear = Integer.toString(year).substring(Math.max(Integer.toString(year).length() - 2, 0));

        newdate = stringDay + "/" + stringMonth + "/" + stringYear;

        return newdate;
    }

    /**
     * If user inputs a day, function will changes the day given by user to the
     * actual date relative to the current calender.
     *
     * @param givenDay
     * @return updatedDate in DD/MM/YY format
     * @throws IllegalValueException
     */
    public static String getNewDate(String givenDay) throws IllegalValueException {

        if (!isValidDay(givenDay)) {
            throw new IllegalValueException(MESSAGE_DAY_CONSTRAINTS);
        }

        int inputDay = getNewDay(givenDay);

        String updatedDate = "";
        String stringDay = "";
        String stringMonth = "";
        String stringYear = "";

        Calendar calendar = Calendar.getInstance(TimeZone.getDefault());
        // getTime() returns the current date in default time zone
        int day = calendar.get(Calendar.DATE);
        // Note: +1 the month for current month
        int month = calendar.get(Calendar.MONTH) + 1;
        int year = calendar.get(Calendar.YEAR);
        int dayOfWeek = calendar.get(Calendar.DAY_OF_WEEK);

        int diffInDays = dayOfWeek - inputDay;

        if (diffInDays == 0) {
            return getCurrentDate();
        }
        if (diffInDays > 0) {
            day += (7 - diffInDays);
        }
        if (diffInDays < 0) {
            day -= diffInDays;
        }

        LocalDate testdate = LocalDate.of(year, month, day);
        int testdays = testdate.lengthOfMonth();

        if (day > testdays) {
            month += 1;
            day -= testdays;
        }
        if (month > 12) {
            month = 1;
            year += 1;
        }

        if (day < 10) {
            stringDay = "0" + Integer.toString(day);
        } else {
            stringDay = Integer.toString(day);
        }
        if (month < 10) {
            stringMonth = "0" + Integer.toString(month);
        } else {
            stringMonth = Integer.toString(month);
        }
        stringYear = Integer.toString(year).substring(Math.max(Integer.toString(year).length() - 2, 0));

        updatedDate = stringDay + "/" + stringMonth + "/" + stringYear;

        return updatedDate;
    }
}
```
###### \java\seedu\taskmanager\logic\commands\ChangeSaveLocationCommand.java
``` java
    public ChangeSaveLocationCommand(File location) {
        this.toSave = location;
    }

    @Override
    public CommandResult execute() throws CommandException {

        try {
            // Optional<Config> optionalConfig =
            // ConfigUtil.readConfig(Config.DEFAULT_CONFIG_FILE);
            // Config config = optionalConfig.get();
            Config config = new Config();
            config.setTaskManagerFilePath(toSave.toString());
            ConfigUtil.saveConfig(config, Config.DEFAULT_CONFIG_FILE);

            XmlTaskManagerStorage.setTaskManagerFilePath(toSave.toString());
            model.saveTaskManager();

            return new CommandResult(String.format(MESSAGE_SUCCESS, toSave));
        } catch (Config.DuplicateTaskManagerFilePathException dtmfpe) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK_MANAGER_FILE_PATH);
        } catch (IOException ioe) {
            logger.warning("Failed to save config file : " + StringUtil.getDetails(ioe));
            throw new CommandException(MESSAGE_CREATED_NEW_CONFIG_FILE);
        }
    }

}
```
###### \java\seedu\taskmanager\logic\commands\DeleteCommand.java
``` java
/**
 * Deletes a task identified using it's last displayed index from the task
 * manager.
 */
public class DeleteCommand extends Command {

    public static final String COMMAND_WORD = "DELETE";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Deletes the task(s) identified by the index number or task name or task date used "
            + "in the last task listing.\n"
            + "Parameters: INDEX (must be a positive integer)\n" + "Example: " + COMMAND_WORD + " 1\n"
            + "Parameters: TASK NAME (must be a valid task name)\n" + "Example: " + COMMAND_WORD
            + " Eat lunch with mum\n" + "Parameters: TASK DATE (must be a valid task date)\n" + "Example: "
            + COMMAND_WORD + " 15/07/17";

    public static final String MESSAGE_DELETE_TASK_SUCCESS = "Deleted task: %1$s";
    public static final String MESSAGE_DELETE_TASKS_DATE_SUCCESS = "Deleted tasks on: ";

    public static final String DELETE_COMMAND_VALIDATION_REGEX_1 = "\\d+";
    public static final String DELETE_COMMAND_VALIDATION_REGEX_2 = "[a-zA-Z]+";
    public static final String DELETE_COMMAND_VALIDATION_REGEX_3 = "\\d{2}/\\d{2}/\\d{2}";

    public static final int DELETE_INDEX_NOT_PRESENT_TOKEN = -1;
    public static final String DELETE_TASKNAME_KEYWORD_NOT_PRESENT_TOKEN = "";
    public static final String DELETE_DATE_KEYWORD_NOT_PRESENT_TOKEN = "";

    public static final String MESSAGE_INVALID_TASK_DATE = "There is no task with the date specified to delete.";
    public static final String MESSAGE_INVALID_TASK_NAME = "There is no task with the name specified to delete.";

    public final int targetIndex;
    public final String targetTaskName;
    public final String targetDate;

    public DeleteCommand(int targetIndex) {
        this.targetIndex = targetIndex;
        this.targetTaskName = DELETE_TASKNAME_KEYWORD_NOT_PRESENT_TOKEN;
        this.targetDate = DELETE_DATE_KEYWORD_NOT_PRESENT_TOKEN;
    }

    public DeleteCommand(String targetString) {
        this.targetIndex = DELETE_INDEX_NOT_PRESENT_TOKEN;
        if (targetString.matches(DELETE_COMMAND_VALIDATION_REGEX_3)) {
            this.targetTaskName = DELETE_TASKNAME_KEYWORD_NOT_PRESENT_TOKEN;
            this.targetDate = targetString;
        } else {
            this.targetTaskName = targetString;
            this.targetDate = DELETE_DATE_KEYWORD_NOT_PRESENT_TOKEN;
        }
    }

    @Override
    public CommandResult execute() throws CommandException {

        if (targetIndex != DELETE_INDEX_NOT_PRESENT_TOKEN) {

            UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

            if (lastShownList.size() < targetIndex) {
                throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
            }

            ReadOnlyTask taskToDelete = lastShownList.get(targetIndex - 1);

            try {
                model.deleteTask(taskToDelete);
            } catch (TaskNotFoundException pnfe) {
                assert false : "The target task cannot be missing";
            }

            return new CommandResult(String.format(MESSAGE_DELETE_TASK_SUCCESS, taskToDelete));

        } else {
            if (!targetDate.equals(DELETE_DATE_KEYWORD_NOT_PRESENT_TOKEN)) {

                final String[] keywords = targetDate.split("\\s+");
                final Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));

                model.updateFilteredTaskList(keywordSet);

                UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

                if (lastShownList.size() == 0) {
                    model.updateFilteredListToShowAll();
                    throw new CommandException(MESSAGE_INVALID_TASK_DATE);
                }

                try {
                    model.deleteTasksDate(lastShownList);
                } catch (TaskNotFoundException e) {
                    assert false : "The target tasks cannot be missing";
                }

                return new CommandResult(String.format(MESSAGE_DELETE_TASKS_DATE_SUCCESS, targetDate));
            } else {

                final String[] keywords = { "" };
                keywords[0] = targetTaskName.trim();

                final Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));

                model.updateFilteredTaskList(keywordSet);

                UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

                if (lastShownList.size() == 0) {
                    model.updateFilteredListToShowAll();
                    throw new CommandException(MESSAGE_INVALID_TASK_NAME);
                }

                try {
                    model.deleteTasksName(lastShownList, targetTaskName);
                } catch (TaskNotFoundException e) {
                    assert false : "The target tasks cannot be missing";
                }

                return new CommandResult(String.format(MESSAGE_DELETE_TASK_SUCCESS, targetTaskName));
            }
        }
    }
}
```
###### \java\seedu\taskmanager\logic\commands\UpdateCommand.java
``` java
/**
 * Updates the details of an existing task in the task manager.
 */
public class UpdateCommand extends Command {

    public static final String COMMAND_WORD = "UPDATE";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Updates the details of the task identified "
            + "by the index number used in the last task listing. "
            + "Existing values will be overwritten by the input values.\n"
            + "Parameters: INDEX (must be a positive integer) [TASK] ON [DATE] FROM [STARTTIME] TO [ENDTIME]\n"
            + "Example: " + COMMAND_WORD + " 1 ON 04/03/17 FROM 1630 TO 1830";

    public static final String MESSAGE_UPDATE_TASK_SUCCESS = "Updated Task: %1$s";
    public static final String MESSAGE_NOT_UPDATED = "At least one field to edit must be provided.";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the task manager.";

    private final int filteredTaskListIndex;
    private final UpdateTaskDescriptor updateTaskDescriptor;

    /**
     * @param filteredTaskListIndex
     *            the index of the task in the filtered task list to update
     * @param updateTaskDescriptor
     *            details to update the task with
     */
    public UpdateCommand(int filteredTaskListIndex, UpdateTaskDescriptor updateTaskDescriptor) {
        assert filteredTaskListIndex > 0;
        assert updateTaskDescriptor != null;

        // converts filteredTaskListIndex from one-based to zero-based.
        this.filteredTaskListIndex = filteredTaskListIndex - 1;

        this.updateTaskDescriptor = new UpdateTaskDescriptor(updateTaskDescriptor);
    }

    @Override
    public CommandResult execute() throws CommandException {
        List<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (filteredTaskListIndex >= lastShownList.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToUpdate = lastShownList.get(filteredTaskListIndex);
        Task updatedTask = createUpdatedTask(taskToUpdate, updateTaskDescriptor);

        try {
            model.updateTask(filteredTaskListIndex, updatedTask);
        } catch (UniqueTaskList.DuplicateTaskException dpe) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        }

        model.updateFilteredListToShowAll();
        return new CommandResult(String.format(MESSAGE_UPDATE_TASK_SUCCESS, taskToUpdate));
    }

    /**
     * Creates and returns a {@code Task} with the details of {@code taskToEdit}
     * edited with {@code editTaskDescriptor}.
     */
    private static Task createUpdatedTask(ReadOnlyTask taskToUpdate, UpdateTaskDescriptor updateTaskDescriptor) {
        assert taskToUpdate != null;

        TaskName updatedTaskName = updateTaskDescriptor.getTaskName().orElseGet(taskToUpdate::getTaskName);
        Date updatedDate = updateTaskDescriptor.getDate().orElseGet(taskToUpdate::getDate);
        StartTime updatedStartTime = updateTaskDescriptor.getStartTime().orElseGet(taskToUpdate::getStartTime);
        EndTime updatedEndTime = updateTaskDescriptor.getEndTime().orElseGet(taskToUpdate::getEndTime);
        // UniqueCategoryList updatedCategories =
        // updateTaskDescriptor.getCategories().orElseGet(taskToUpdate::getCategories);

        return new Task(updatedTaskName, updatedDate, updatedStartTime,
                updatedEndTime/* , updatedCategories */);
    }

    /**
     * Stores the details to edit the task with. Each non-empty field value will
     * replace the corresponding field value of the task.
     */
    public static class UpdateTaskDescriptor {
        private Optional<TaskName> taskname = Optional.empty();
        private Optional<Date> date = Optional.empty();
        private Optional<StartTime> starttime = Optional.empty();
        private Optional<EndTime> endtime = Optional.empty();
        // private Optional<UniqueCategoryList> categories = Optional.empty();

        public UpdateTaskDescriptor() {
        }

        public UpdateTaskDescriptor(UpdateTaskDescriptor toCopy) {
            this.taskname = toCopy.getTaskName();
            this.date = toCopy.getDate();
            this.starttime = toCopy.getStartTime();
            this.endtime = toCopy.getEndTime();
            // this.categories = toCopy.getCategories();
        }

        /**
         * Returns true if at least one field is updated.
         */
        public boolean isAnyFieldUpdated() {
            return CollectionUtil.isAnyPresent(this.taskname, this.date, this.starttime, this.endtime
                    /*, this.categories*/);
        }

        public void setTaskName(Optional<TaskName> taskname) {
            assert taskname != null;
            this.taskname = taskname;
        }

        public Optional<TaskName> getTaskName() {
            return taskname;
        }

        public void setDate(Optional<Date> date) {
            assert date != null;
            this.date = date;
        }

        public Optional<Date> getDate() {
            return date;
        }

        public void setStartTime(Optional<StartTime> starttime) {
            assert starttime != null;
            this.starttime = starttime;
        }

        public Optional<StartTime> getStartTime() {
            return starttime;
        }

        public void setEndTime(Optional<EndTime> endtime) {
            assert endtime != null;
            this.endtime = endtime;
        }

        public Optional<EndTime> getEndTime() {
            return endtime;
        }

        /*
         * public void setCategories(Optional<UniqueCategoryList> categories) {
         * assert categories != null; this.categories = categories; }
         *
         * public Optional<UniqueCategoryList> getCategories() { return
         * categories; }
         */
    }
}
```
###### \java\seedu\taskmanager\logic\parser\ChangeSaveLocationCommandParser.java
``` java
public class ChangeSaveLocationCommandParser {

    public static final String INVALID_SAVE_LOCATION = "Invalid input for save location";

    /**
     * Parses the given {@code String} of arguments in the context of the
     * ChangeSaveLocationCommand and returns an ChangeSaveLocationCommand object
     * for execution.
     */

    public Command parse(String args) {

        // assert args != null;

        String stringSaveLocation = args;
        File checkLocation = new File(args.trim());

        if (("".equals(stringSaveLocation))) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, ChangeSaveLocationCommand.MESSAGE_USAGE));
        }
        if (!checkLocation.exists()) {
            return new IncorrectCommand(String.format(ChangeSaveLocationCommand.MESSAGE_USAGE, INVALID_SAVE_LOCATION));
        }

        if (!(stringSaveLocation.substring(stringSaveLocation.length() - 1).equals("/"))) {
            stringSaveLocation += "/";
        }

        stringSaveLocation += "taskmanager.xml";
        File saveLocation = new File(stringSaveLocation.trim());

        return new ChangeSaveLocationCommand(saveLocation);
    }

}
```
###### \java\seedu\taskmanager\logic\parser\DeleteCommandParser.java
``` java
/**
 * Parses input arguments and creates a new DeleteCommand object
 */
public class DeleteCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the
     * DeleteCommand and returns an DeleteCommand object for execution.
     */
    public Command parse(String args) {
        assert args != null;

        if (args.trim().matches(DeleteCommand.DELETE_COMMAND_VALIDATION_REGEX_1)) {
            Optional<Integer> index = ParserUtil.parseIndex(args);
            if (!index.isPresent()) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
            }
            return new DeleteCommand(index.get());
        } else {
            if (args.isEmpty()) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
            }
            return new DeleteCommand(args.trim());
        }
    }
}
```
###### \java\seedu\taskmanager\logic\parser\UpdateCommandParser.java
``` java
/**
 * Parses input arguments and creates a new EditCommand object
 */
public class UpdateCommandParser {

    public static final String EMPTY_FIELD = "EMPTY_FIELD";
    public static final String INVALID_TIME = "Invalid input for time\nTime must be between 0000 and 2359";

    /**
     * Parses the given {@code String} of arguments in the context of the
     * EditCommand and returns an EditCommand object for execution.
     */
    public Command parse(String args) {
        assert args != null;
        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(PREFIX_DATE, PREFIX_DEADLINE, PREFIX_STARTTIME,
                PREFIX_ENDTIME/* , PREFIX_CATEGORY */);
        argsTokenizer.tokenize(args);
        List<Optional<String>> preambleFields = ParserUtil.splitPreamble(argsTokenizer.getPreamble().orElse(""), 2);

        Optional<Integer> index = preambleFields.get(0).flatMap(ParserUtil::parseIndex);
        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UpdateCommand.MESSAGE_USAGE));
        }

        UpdateTaskDescriptor updateTaskDescriptor = new UpdateTaskDescriptor();
        try {
            Optional<String> taskName = preambleFields.get(1);
            Optional<String> date = argsTokenizer.getValue(PREFIX_DATE);
            Optional<String> deadline = argsTokenizer.getValue(PREFIX_DEADLINE);
            Optional<String> startTime = argsTokenizer.getValue(PREFIX_STARTTIME);
            Optional<String> endTime = argsTokenizer.getValue(PREFIX_ENDTIME);

            /*
             * Checks to ensure correct combinations of arguments are added by
             * user when adding tasks to the task manager
             */

            if (!date.isPresent() || !deadline.isPresent() || !startTime.isPresent() || !endTime.isPresent()) {
                if ((date.isPresent()) && ((deadline.isPresent()) || (startTime.isPresent()))) {
                    throw new NoSuchElementException("");
                }
                if ((deadline.isPresent())
                        && ((date.isPresent()) || (startTime.isPresent()) || (endTime.isPresent()))) {
                    throw new NoSuchElementException("");
                }
                if (((startTime.isPresent()) && (!date.isPresent() && !deadline.isPresent() && !endTime.isPresent()))
                        || ((startTime.isPresent()) && ((date.isPresent()) || (deadline.isPresent())))) {
                    throw new NoSuchElementException("");
                }
                if ((endTime.isPresent()) && (!date.isPresent() && !startTime.isPresent())) {
                    throw new NoSuchElementException("");
                }
            }

            String stringDate = date.orElse("");
            String stringStartTime = startTime.orElse("");
            String stringEndTime = endTime.orElse("");

            /*
             * To parse date input if required and throws exceptions if
             * incorrect arguments of date are included
             */

            if (date.isPresent()) {
                String[] splited = stringDate.split("\\s+");
                stringDate = splited[0];
                try {
                    stringStartTime = splited[1];
                    if (Integer.parseInt(stringStartTime) >= 2400) {
                        throw new IllegalValueException(INVALID_TIME);
                    }
                    if (("").equals(stringEndTime)) {
                        stringEndTime = Integer.toString(100 + Integer.parseInt(splited[1]));
                    } else {
                        String[] splitedEndTime = stringEndTime.split("\\s+");
                        try {
                            if (!(splitedEndTime[1].isEmpty())) {
                                throw new IllegalValueException("Incorrect input after TO prefix.\n"
                                        + "Example of Allowed Format: ADD task ON thursday 1200 TO 1400\n"
                                        + "Type HELP for user guide with detailed explanations of all commands");
                            }
                        } catch (ArrayIndexOutOfBoundsException aioobe) {
                            stringEndTime = splitedEndTime[0];
                            if (Integer.parseInt(stringEndTime) >= 2400) {
                                throw new IllegalValueException(INVALID_TIME);
                            }
                        }
                    }
                } catch (ArrayIndexOutOfBoundsException aioobe) {
                    stringStartTime = "0000";
                    if (("").equals(stringEndTime)) {
                        stringEndTime = "2359";
                    } else {
                        String[] splitedEndTime = stringEndTime.split("\\s+");
                        try {
                            if (!(splitedEndTime[1].isEmpty())) {
                                throw new IllegalValueException("Incorrect input after TO prefix.\n"
                                        + "Example of Allowed Format: ADD task ON thursday 1200 TO 1400\n"
                                        + "Type HELP for user guide with detailed explanations of all commands");
                            }
                        } catch (ArrayIndexOutOfBoundsException aiobe) {
                            stringEndTime = splitedEndTime[0];
                            if (Integer.parseInt(stringEndTime) >= 2400) {
                                throw new IllegalValueException(INVALID_TIME);
                            }
                        }
                    }
                }
                try {
                    if (!(splited[2].isEmpty())) {
                        throw new NoSuchElementException("");
                    }
                } catch (ArrayIndexOutOfBoundsException aioobe) {
                }
                if (Integer.parseInt(stringStartTime) > Integer.parseInt(stringEndTime)) {
                    throw new IllegalValueException(
                            "Invalid input of time, start time has to be earlier than end time");
                }
            }

            if (stringStartTime.matches("[a-zA-Z]+")) {
                StringBuilder stringBuilderStartTime = new StringBuilder();

                stringBuilderStartTime.append(stringStartTime);
                stringBuilderStartTime.append(" ");
                stringBuilderStartTime.append("0000");

                stringStartTime = stringBuilderStartTime.toString();
            }

            if (stringEndTime.matches("[a-zA-Z]+")) {
                StringBuilder stringBuilderEndTime = new StringBuilder();

                stringBuilderEndTime.append(stringEndTime);
                stringBuilderEndTime.append(" ");
                stringBuilderEndTime.append("2359");

                stringEndTime = stringBuilderEndTime.toString();
            }

            if ((startTime.isPresent()) && (!stringStartTime.matches("\\d+"))) {
                String[] splitedStartTime = stringStartTime.split("\\s+");
                try {
                    if (splitedStartTime[0].matches(DATE_VALIDATION_REGEX2)) {
                        splitedStartTime[0] = CurrentDate.getNewDate(splitedStartTime[0]);
                    }
                    StringBuilder stringBuilder = new StringBuilder();

                    stringBuilder.append(splitedStartTime[0]);
                    stringBuilder.append(" ");
                    stringBuilder.append(splitedStartTime[1]);

                    stringStartTime = stringBuilder.toString();
                } catch (ArrayIndexOutOfBoundsException aioobe) {
                    if (splitedStartTime[0].matches(DATE_VALIDATION_REGEX2)) {
                        stringStartTime = CurrentDate.getNewDate(splitedStartTime[0]);
                    }
                }
            }

            if ((endTime.isPresent()) && (!stringEndTime.matches("\\d+"))) {
                String[] splitedEndTime = stringEndTime.split("\\s+");
                try {
                    if (splitedEndTime[0].matches(DATE_VALIDATION_REGEX2)) {
                        splitedEndTime[0] = CurrentDate.getNewDate(splitedEndTime[0]);
                    }
                    StringBuilder stringBuilder = new StringBuilder();

                    stringBuilder.append(splitedEndTime[0]);
                    stringBuilder.append(" ");
                    stringBuilder.append(splitedEndTime[1]);

                    stringEndTime = stringBuilder.toString();
                } catch (ArrayIndexOutOfBoundsException aioobe) {
                    if (splitedEndTime[0].matches(DATE_VALIDATION_REGEX2)) {
                        stringEndTime = CurrentDate.getNewDate(splitedEndTime[0]);
                    }
                }
            }

            /*
             * To parse deadline input if required and throws exceptions if
             * incorrect arguments of deadline are included
             */

            if (deadline.isPresent()) {
                String stringDeadline = deadline.get();
                String[] splited = stringDeadline.trim().split("\\s+");
                stringDate = splited[0];
                try {
                    stringEndTime = splited[1];
                    if (Integer.parseInt(stringEndTime) >= 2400) {
                        throw new IllegalValueException(INVALID_TIME);
                    }
                } catch (ArrayIndexOutOfBoundsException aioobe) {
                    stringEndTime = "2359";
                } catch (NumberFormatException nfe) {
                    return new IncorrectCommand("Invalid input after prefix BY\n"
                            + "Example of Allowed Format: ADD project meeting BY thursday 1400 \n"
                            + "Type HELP for user guide with detailed explanations of all commands");
                }
                try {
                    if (!(splited[2].isEmpty())) {
                        throw new NoSuchElementException("");
                    }
                } catch (ArrayIndexOutOfBoundsException aioobe) {
                }
            }

            if (!("").equals(stringStartTime)) {
                startTime = Optional.of(stringStartTime);
            } else {
                startTime = Optional.of(EMPTY_FIELD);
            }
            if (!("").equals(stringEndTime)) {
                endTime = Optional.of(stringEndTime);
            } else {
                endTime = Optional.of(EMPTY_FIELD);
            }
            if (!("").equals(stringDate)) {
                date = Optional.of(stringDate);
            } else {
                date = Optional.of(EMPTY_FIELD);
            }

            if (date.isPresent()) {
                if (date.get().matches(DATE_VALIDATION_REGEX2)) {
                    date = Optional.of(CurrentDate.getNewDate(date.get()));
                }
            }

            updateTaskDescriptor.setTaskName(ParserUtil.parseTaskName(taskName));
            updateTaskDescriptor.setDate(ParserUtil.parseDate(date));
            updateTaskDescriptor.setStartTime(ParserUtil.parseStartTime(startTime));
            updateTaskDescriptor.setEndTime(ParserUtil.parseEndTime(endTime));

            // updateTaskDescriptor.setCategories(parseCategoriesForUpdate(
            // ParserUtil.toSet(argsTokenizer.getAllValues(PREFIX_CATEGORY))));
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        } catch (NoSuchElementException nsee) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UpdateCommand.MESSAGE_USAGE));
        } catch (ArrayIndexOutOfBoundsException aioobe) {
            return new IncorrectCommand(
                    "Invalid command input!\nExample of Allowed Format: ADD e-mail John BY thursday 1400\n"
                            + "Type HELP for user guide with detailed explanations of all commands");
        } catch (NumberFormatException nfe) {
            return new IncorrectCommand("Invalid input after prefix TO, only input of time is allowed\n"
                    + "Example of Allowed Format: ADD project meeting ON thursday 1400 TO 1800\n"
                    + "Type HELP for user guide with detailed explanations of all commands");
        }

        if (!updateTaskDescriptor.isAnyFieldUpdated()) {
            return new IncorrectCommand(UpdateCommand.MESSAGE_NOT_UPDATED);
        }
        return new UpdateCommand(index.get(), updateTaskDescriptor);
    }

    /**
     * Parses {@code Collection<String> tags} into an
     * {@code Optional<UniqueTagList>} if {@code tags} is non-empty. If
     * {@code tags} contain only one element which is an empty string, it will
     * be parsed into a {@code Optional<UniqueTagList>} containing zero tags.
     */
    /*
     * private Optional<UniqueCategoryList>
     * parseCategoriesForUpdate(Collection<String> categories) throws
     * IllegalValueException { assert categories != null;
     *
     * if (categories.isEmpty()) { return Optional.empty(); } Collection<String>
     * categorySet = categories.size() == 1 && categories.contains("") ?
     * Collections.emptySet() : categories; return
     * Optional.of(ParserUtil.parseCategories(categorySet)); }
     */
}
```
###### \java\seedu\taskmanager\model\Model.java
``` java
    /** Deletes tasks by their date. */
    void deleteTasksDate(UnmodifiableObservableList<ReadOnlyTask> targets) throws UniqueTaskList.TaskNotFoundException;

    /** Deletes the task by its name. */
    void deleteTasksName(UnmodifiableObservableList<ReadOnlyTask> targets, String toDeleteTaskName)
            throws UniqueTaskList.TaskNotFoundException;

```
###### \java\seedu\taskmanager\model\ModelManager.java
``` java
    @Override
    public synchronized void deleteTasksDate(UnmodifiableObservableList<ReadOnlyTask> targets)
            throws TaskNotFoundException {
        while (targets.size() != 0) {
            try {
                ReadOnlyTask taskToDelete = targets.get(0);
                taskManager.removeTask(taskToDelete);
            } catch (TaskNotFoundException pnfe) {
                assert false : "The target task cannot be missing";
            }
        }
        updateFilteredListToShowAll();
        indicateTaskManagerChanged();
    }

    @Override
    public synchronized void deleteTasksName(UnmodifiableObservableList<ReadOnlyTask> targets, String toDeleteTaskName)
            throws TaskNotFoundException {
        while (targets.size() != 0) {
            try {
                ReadOnlyTask taskToDelete = targets.get(0);
                if (toDeleteTaskName.equals(taskToDelete.getTaskName().fullTaskName)) {
                    taskManager.removeTask(taskToDelete);
                    break;
                }
            } catch (TaskNotFoundException pnfe) {
                assert false : "The target task cannot be missing";
            }
        }
        updateFilteredListToShowAll();
        indicateTaskManagerChanged();
    }

```
###### \java\seedu\taskmanager\ui\TaskCard.java
``` java
public class TaskCard extends UiPart<Region> {

    private static final String FXML = "TaskCard.fxml";

    @FXML
    private HBox cardPane;
    @FXML
    private Label taskname;
    @FXML
    private Label id;
    @FXML
    private Label date;
    @FXML
    private Label startTime;
    @FXML
    private Label endTime;
    @FXML
    private Label toLabel;
    // @FXML
    // private FlowPane categories;

    private final StringProperty empty = new SimpleStringProperty("");
    private final StringProperty to = new SimpleStringProperty("to");

    public TaskCard(ReadOnlyTask task, int displayedIndex) {
        super(FXML);
        taskname.setText(task.getTaskName().fullTaskName);
        id.setText(displayedIndex + ". ");
        if ((task.getDate().value).equals("EMPTY_FIELD")) {
            date.textProperty().bind(empty);
        } else {
            date.setText(task.getDate().value);
        }
        if ((task.getStartTime().value).equals("EMPTY_FIELD")) {
            startTime.textProperty().bind(empty);
        } else {
            startTime.setText(task.getStartTime().value);
        }
        if ((task.getEndTime().value).equals("EMPTY_FIELD")) {
            endTime.textProperty().bind(empty);
            toLabel.textProperty().bind(empty);
        } else {
            if ((task.getStartTime().value).equals("EMPTY_FIELD")) {
                endTime.setText(task.getEndTime().value);
                toLabel.textProperty().bind(empty);
            } else {
                endTime.setText(task.getEndTime().value);
                toLabel.textProperty().bind(to);
            }
        }
        // initCategory(task);
    }
    /*
     * private void initCategory(ReadOnlyTask task) {
     * task.getCategories().forEach(category -> categories.getChildren().add(new
     * Label(category.categoryName))); }
     */
}
```
