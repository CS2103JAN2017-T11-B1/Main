# A0142418L
###### \java\seedu\taskmanager\commons\core\Config.java
``` java
    public void setTaskManagerFilePath(String taskManagerFilePath) throws DuplicateTaskManagerFilePathException {
        if (this.taskManagerFilePath.equals(taskManagerFilePath)) {
            throw new DuplicateTaskManagerFilePathException();
        } else {
            this.taskManagerFilePath = taskManagerFilePath;
        }
    }

```
###### \java\seedu\taskmanager\commons\core\Config.java
``` java
    /**
     * Signals that the file path specified is the same as the current one.
     */
    public static class DuplicateTaskManagerFilePathException extends DuplicateDataException {
        protected DuplicateTaskManagerFilePathException() {
            super("Operation would result in duplicate tasks");
        }
    }

```
###### \java\seedu\taskmanager\commons\util\CurrentDate.java
``` java
public class CurrentDate {

    public static final String MESSAGE_DAY_CONSTRAINTS = "Task date should be either "
            + "a day (e.g. thursday) or a date with the format: DD/MM/YY (e.g. 03/03/17)\n"
            + "May also include time (e.g. 1400) behind date \n"
            + "Enter HELP for user guide with detailed explanations of all commands";

    public static final String CURRENTDATE_VALIDATION_REGEX_TODAY1 = "Today";
    public static final String CURRENTDATE_VALIDATION_REGEX_TODAY2 = "today";
    public static final String CURRENTDATE_VALIDATION_REGEX_TOMORROW1 = "Tomorrow";
    public static final String CURRENTDATE_VALIDATION_REGEX_TOMORROW2 = "tomorrow";
    public static final String CURRENTDATE_VALIDATION_REGEX_TOMORROW3 = "Tmr";
    public static final String CURRENTDATE_VALIDATION_REGEX_TOMORROW4 = "tmr";
    public static final String CURRENTDATE_VALIDATION_REGEX_MONDAY1 = "Monday";
    public static final String CURRENTDATE_VALIDATION_REGEX_MONDAY2 = "monday";
    public static final String CURRENTDATE_VALIDATION_REGEX_MONDAY3 = "Mon";
    public static final String CURRENTDATE_VALIDATION_REGEX_MONDAY4 = "mon";
    public static final String CURRENTDATE_VALIDATION_REGEX_TUESDAY1 = "Tuesday";
    public static final String CURRENTDATE_VALIDATION_REGEX_TUESDAY2 = "tuesday";
    public static final String CURRENTDATE_VALIDATION_REGEX_TUESDAY3 = "Tues";
    public static final String CURRENTDATE_VALIDATION_REGEX_TUESDAY4 = "tues";
    public static final String CURRENTDATE_VALIDATION_REGEX_WEDNESDAY1 = "Wednesday";
    public static final String CURRENTDATE_VALIDATION_REGEX_WEDNESDAY2 = "wednesday";
    public static final String CURRENTDATE_VALIDATION_REGEX_WEDNESDAY3 = "Wed";
    public static final String CURRENTDATE_VALIDATION_REGEX_WEDNESDAY4 = "wed";
    public static final String CURRENTDATE_VALIDATION_REGEX_THURSDAY1 = "Thursday";
    public static final String CURRENTDATE_VALIDATION_REGEX_THURSDAY2 = "thursday";
    public static final String CURRENTDATE_VALIDATION_REGEX_THURSDAY3 = "Thurs";
    public static final String CURRENTDATE_VALIDATION_REGEX_THURSDAY4 = "thurs";
    public static final String CURRENTDATE_VALIDATION_REGEX_FRIDAY1 = "Friday";
    public static final String CURRENTDATE_VALIDATION_REGEX_FRIDAY2 = "friday";
    public static final String CURRENTDATE_VALIDATION_REGEX_FRIDAY3 = "Fri";
    public static final String CURRENTDATE_VALIDATION_REGEX_FRIDAY4 = "fri";
    public static final String CURRENTDATE_VALIDATION_REGEX_SATURDAY1 = "Saturday";
    public static final String CURRENTDATE_VALIDATION_REGEX_SATURDAY2 = "saturday";
    public static final String CURRENTDATE_VALIDATION_REGEX_SATURDAY3 = "Sat";
    public static final String CURRENTDATE_VALIDATION_REGEX_SATURDAY4 = "sat";
    public static final String CURRENTDATE_VALIDATION_REGEX_SUNDAY1 = "Sunday";
    public static final String CURRENTDATE_VALIDATION_REGEX_SUNDAY2 = "sunday";
    public static final String CURRENTDATE_VALIDATION_REGEX_SUNDAY3 = "Sun";
    public static final String CURRENTDATE_VALIDATION_REGEX_SUNDAY4 = "sun";

    public static int currentDay;
    public static String currentDate = "";

    public CurrentDate() {
        currentDay = getCurrentDay();
        currentDate = getCurrentDate();
    }

    /**
     * Checks to see if user has input a valid day, this function includes
     * different spellings of the same day
     */
    public static boolean isValidDay(String test) {
        return test.matches(CURRENTDATE_VALIDATION_REGEX_MONDAY1) || test.matches(CURRENTDATE_VALIDATION_REGEX_MONDAY2)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_MONDAY3)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_MONDAY4)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_TUESDAY1)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_TUESDAY2)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_TUESDAY3)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_TUESDAY4)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_WEDNESDAY1)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_WEDNESDAY2)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_WEDNESDAY3)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_WEDNESDAY4)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_THURSDAY1)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_THURSDAY2)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_THURSDAY3)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_THURSDAY4)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_FRIDAY1)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_FRIDAY2)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_FRIDAY3)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_FRIDAY4)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_SATURDAY1)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_SATURDAY2)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_SATURDAY3)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_SATURDAY4)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_SUNDAY1)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_SUNDAY2)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_SUNDAY3)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_SUNDAY4)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_TODAY1)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_TODAY2)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_TOMORROW1)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_TOMORROW2)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_TOMORROW3)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_TOMORROW4);
    }

    /**
     * @return Day number relative to the day itself (e.g. Sunday == 1 &
     *         Wednesday == 4)
     */
    public static int getNewDay(String day) {

        if (day.matches(CURRENTDATE_VALIDATION_REGEX_SUNDAY1) || day.matches(CURRENTDATE_VALIDATION_REGEX_SUNDAY2)
                || day.matches(CURRENTDATE_VALIDATION_REGEX_SUNDAY3)
                || day.matches(CURRENTDATE_VALIDATION_REGEX_SUNDAY4)) {
            return 1;
        } else {
            if (day.matches(CURRENTDATE_VALIDATION_REGEX_MONDAY1) || day.matches(CURRENTDATE_VALIDATION_REGEX_MONDAY2)
                    || day.matches(CURRENTDATE_VALIDATION_REGEX_MONDAY3)
                    || day.matches(CURRENTDATE_VALIDATION_REGEX_MONDAY4)) {
                return 2;
            } else {
                if (day.matches(CURRENTDATE_VALIDATION_REGEX_TUESDAY1)
                        || day.matches(CURRENTDATE_VALIDATION_REGEX_TUESDAY2)
                        || day.matches(CURRENTDATE_VALIDATION_REGEX_TUESDAY3)
                        || day.matches(CURRENTDATE_VALIDATION_REGEX_TUESDAY4)) {
                    return 3;
                } else {
                    if (day.matches(CURRENTDATE_VALIDATION_REGEX_WEDNESDAY1)
                            || day.matches(CURRENTDATE_VALIDATION_REGEX_WEDNESDAY2)
                            || day.matches(CURRENTDATE_VALIDATION_REGEX_WEDNESDAY3)
                            || day.matches(CURRENTDATE_VALIDATION_REGEX_WEDNESDAY4)) {
                        return 4;
                    } else {
                        if (day.matches(CURRENTDATE_VALIDATION_REGEX_THURSDAY1)
                                || day.matches(CURRENTDATE_VALIDATION_REGEX_THURSDAY2)
                                || day.matches(CURRENTDATE_VALIDATION_REGEX_THURSDAY3)
                                || day.matches(CURRENTDATE_VALIDATION_REGEX_THURSDAY4)) {
                            return 5;
                        } else {
                            if (day.matches(CURRENTDATE_VALIDATION_REGEX_FRIDAY1)
                                    || day.matches(CURRENTDATE_VALIDATION_REGEX_FRIDAY2)
                                    || day.matches(CURRENTDATE_VALIDATION_REGEX_FRIDAY3)
                                    || day.matches(CURRENTDATE_VALIDATION_REGEX_FRIDAY4)) {
                                return 6;
                            } else {
                                if (day.matches(CURRENTDATE_VALIDATION_REGEX_SATURDAY1)
                                        || day.matches(CURRENTDATE_VALIDATION_REGEX_SATURDAY2)
                                        || day.matches(CURRENTDATE_VALIDATION_REGEX_SATURDAY3)
                                        || day.matches(CURRENTDATE_VALIDATION_REGEX_SATURDAY4)) {
                                    return 7;
                                } else {
                                    if (day.matches(CURRENTDATE_VALIDATION_REGEX_TODAY1)
                                            || day.matches(CURRENTDATE_VALIDATION_REGEX_TODAY2)) {
                                        Calendar calendar = Calendar.getInstance(TimeZone.getDefault());
                                        int dayOfWeek = calendar.get(Calendar.DAY_OF_WEEK);

                                        return dayOfWeek;
                                    } else {
                                        Calendar calendar = Calendar.getInstance(TimeZone.getDefault());
                                        int dayOfWeek = calendar.get(Calendar.DAY_OF_WEEK);

                                        if (dayOfWeek + 1 == 8) {
                                            return dayOfWeek = 1;
                                        } else {
                                            return dayOfWeek + 1;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    /**
     * @return Current Day with respect to the date on the computer
     */
    public static int getCurrentDay() {
        Calendar calendar = Calendar.getInstance(TimeZone.getDefault());
        int day = calendar.get(Calendar.DATE);
        return day;
    }

    /**
     * @return Current Date with respect to the date on the computer
     */
    public static String getCurrentDate() {
        String newdate = "";
        String stringDay = "";
        String stringMonth = "";
        String stringYear = "";

        Calendar calendar = Calendar.getInstance(TimeZone.getDefault());
        // getTime() returns the current date in default time zone
        int day = calendar.get(Calendar.DATE);
        // Note: +1 the month for current month
        int month = calendar.get(Calendar.MONTH) + 1;
        int year = calendar.get(Calendar.YEAR);

        if (day < 10) {
            stringDay = "0" + Integer.toString(day);
        } else {
            stringDay = Integer.toString(day);
        }
        if (month < 10) {
            stringMonth = "0" + Integer.toString(month);
        } else {
            stringMonth = Integer.toString(month);
        }
        stringYear = Integer.toString(year).substring(Math.max(Integer.toString(year).length() - 2, 0));

        newdate = stringDay + "/" + stringMonth + "/" + stringYear;

        return newdate;
    }

    /**
     * If user inputs a day, function will changes the day given by user to the
     * actual date relative to the current calender.
     *
     * @param givenDay
     * @return updatedDate in DD/MM/YY format
     * @throws IllegalValueException
     */
    public static String getNewDate(String givenDay) throws IllegalValueException {

        if (!isValidDay(givenDay)) {
            throw new IllegalValueException(MESSAGE_DAY_CONSTRAINTS);
        }

        int inputDay = getNewDay(givenDay);

        String updatedDate = "";
        String stringDay = "";
        String stringMonth = "";
        String stringYear = "";

        Calendar calendar = Calendar.getInstance(TimeZone.getDefault());
        // getTime() returns the current date in default time zone
        int day = calendar.get(Calendar.DATE);
        // Note: +1 the month for current month
        int month = calendar.get(Calendar.MONTH) + 1;
        int year = calendar.get(Calendar.YEAR);
        int dayOfWeek = calendar.get(Calendar.DAY_OF_WEEK);

        LocalDate testdate = LocalDate.of(year, month, day);
        int testdays = testdate.lengthOfMonth();

        int diffInDays = dayOfWeek - inputDay;

        if (diffInDays == 0) {
            return getCurrentDate();
        }
        if (diffInDays > 0) {
            day += (7 - diffInDays);
        }
        if (diffInDays < 0) {
            day -= diffInDays;
        }

        if (day > testdays) {
            month += 1;
            day -= testdays;
        }
        if (month > 12) {
            month = 1;
            year += 1;
        }

        if (day < 10) {
            stringDay = "0" + Integer.toString(day);
        } else {
            stringDay = Integer.toString(day);
        }
        if (month < 10) {
            stringMonth = "0" + Integer.toString(month);
        } else {
            stringMonth = Integer.toString(month);
        }
        stringYear = Integer.toString(year).substring(Math.max(Integer.toString(year).length() - 2, 0));

        updatedDate = stringDay + "/" + stringMonth + "/" + stringYear;

        return updatedDate;
    }
}
```
###### \java\seedu\taskmanager\logic\commands\ChangeSaveLocationCommand.java
``` java
    public ChangeSaveLocationCommand(File location) {
        this.toSave = location;
    }

    @Override
    public CommandResult execute() throws CommandException {

        try {
            // Optional<Config> optionalConfig =
            // ConfigUtil.readConfig(Config.DEFAULT_CONFIG_FILE);
            // Config config = optionalConfig.get();
            Config config = new Config();
            config.setTaskManagerFilePath(toSave.toString());
            ConfigUtil.saveConfig(config, Config.DEFAULT_CONFIG_FILE);

            XmlTaskManagerStorage.setTaskManagerFilePath(toSave.toString());
            model.saveTaskManager();

            return new CommandResult(String.format(MESSAGE_SUCCESS, toSave));
        } catch (Config.DuplicateTaskManagerFilePathException dtmfpe) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK_MANAGER_FILE_PATH);
        } catch (IOException ioe) {
            logger.warning("Failed to save config file : " + StringUtil.getDetails(ioe));
            throw new CommandException(MESSAGE_CREATED_NEW_CONFIG_FILE);
        }
    }

}
```
###### \java\seedu\taskmanager\logic\commands\DeleteCommand.java
``` java
/**
 * Deletes a task identified using it's last displayed index from the task
 * manager.
 */
public class DeleteCommand extends Command {

    public static final String COMMAND_WORD = "DELETE";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Deletes the task(s) identified by the index number or task name or task date used "
            + "in the last task listing.\n" + "Parameters: INDEX (must be a positive integer)\n" + "Example: "
            + COMMAND_WORD + " 1\n" + "Parameters: TASK NAME (must be a valid task name)\n" + "Example: " + COMMAND_WORD
            + " Eat lunch with mum\n" + "Parameters: TASK DATE (must be a valid task date)\n" + "Example: "
            + COMMAND_WORD + " 15/07/17";

    public static final String MESSAGE_DELETE_TASK_SUCCESS = "Deleted task: %1$s";
    public static final String MESSAGE_DELETE_TASKS_DATE_SUCCESS_1 = "Deleted tasks on: ";
    public static final String MESSAGE_DELETE_TASKS_DATE_SUCCESS_2 = "\nTotal number of task(s) deleted: ";

    public static final String MESSAGE_DELETE_TASKS_NAME_SUCCESS_1 = "Deleted task all tasks with name '";
    public static final String MESSAGE_DELETE_TASKS_NAME_SUCCESS_2 = "' .\nTotal number of task(s) deleted: ";

    public static final String DELETE_COMMAND_VALIDATION_REGEX_1 = "\\d+";
    public static final String DELETE_COMMAND_VALIDATION_REGEX_2 = "[a-zA-Z]+";
    public static final String DELETE_COMMAND_VALIDATION_REGEX_3 = "\\d{2}/\\d{2}/\\d{2}";

    public static final int DELETE_INDEX_NOT_PRESENT_TOKEN = -1;
    public static final String DELETE_TASKNAME_KEYWORD_NOT_PRESENT_TOKEN = "";
    public static final String DELETE_DATE_KEYWORD_NOT_PRESENT_TOKEN = "";

    public static final String MESSAGE_INVALID_TASK_DATE = "There is no task with the date specified to delete.";
    public static final String MESSAGE_INVALID_TASK_NAME = "There is no task with the name specified to delete.";

    public final int targetIndex;
    public final String targetTaskName;
    public final String targetDate;

    public DeleteCommand(int targetIndex) {
        this.targetIndex = targetIndex;
        this.targetTaskName = DELETE_TASKNAME_KEYWORD_NOT_PRESENT_TOKEN;
        this.targetDate = DELETE_DATE_KEYWORD_NOT_PRESENT_TOKEN;
    }

    public DeleteCommand(String targetString) {
        this.targetIndex = DELETE_INDEX_NOT_PRESENT_TOKEN;
        if (targetString.matches(DELETE_COMMAND_VALIDATION_REGEX_3)) {
            this.targetTaskName = DELETE_TASKNAME_KEYWORD_NOT_PRESENT_TOKEN;
            this.targetDate = targetString;
        } else {
            this.targetTaskName = targetString;
            this.targetDate = DELETE_DATE_KEYWORD_NOT_PRESENT_TOKEN;
        }
    }

    @Override
    public CommandResult execute() throws CommandException {

        int numDeletedTasks = 0;

        if (targetIndex != DELETE_INDEX_NOT_PRESENT_TOKEN) {

            UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

            if (lastShownList.size() < targetIndex) {
                throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
            }

            ReadOnlyTask taskToDelete = lastShownList.get(targetIndex - 1);

            try {
                model.deleteTask(taskToDelete);
            } catch (TaskNotFoundException pnfe) {
                assert false : "The target task cannot be missing";
            }

            return new CommandResult(String.format(MESSAGE_DELETE_TASK_SUCCESS, taskToDelete));

        } else {
            if (!targetDate.equals(DELETE_DATE_KEYWORD_NOT_PRESENT_TOKEN)) {

                final String[] keywords = targetDate.split("\\s+");
                final Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));

                model.updateFilteredTaskList(keywordSet);

                UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

                if (lastShownList.size() == 0) {
                    model.updateFilteredListToShowAll();
                    throw new CommandException(MESSAGE_INVALID_TASK_DATE);
                }

                try {
                    numDeletedTasks = model.deleteTasksDate(lastShownList);
                } catch (TaskNotFoundException e) {
                    assert false : "The target tasks cannot be missing";
                }

                return new CommandResult(MESSAGE_DELETE_TASKS_DATE_SUCCESS_1 + targetDate +
                        MESSAGE_DELETE_TASKS_DATE_SUCCESS_2 + Integer.toString(numDeletedTasks));
            } else {

                final String[] keywords = { "" };
                keywords[0] = targetTaskName.trim();

                final Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));

                model.updateFilteredTaskList(keywordSet);

                UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

                if (lastShownList.size() == 0) {
                    model.updateFilteredListToShowAll();
                    throw new CommandException(MESSAGE_INVALID_TASK_NAME);
                }

                try {
                    numDeletedTasks = model.deleteTasksName(lastShownList, targetTaskName);
                } catch (TaskNotFoundException e) {
                    assert false : "The target tasks cannot be missing";
                }

                return new CommandResult(MESSAGE_DELETE_TASKS_NAME_SUCCESS_1 + targetTaskName +
                        MESSAGE_DELETE_TASKS_NAME_SUCCESS_2 + Integer.toString(numDeletedTasks));
            }
        }
    }
}
```
###### \java\seedu\taskmanager\logic\commands\RedoCommand.java
``` java
/**
 * Redo the previous action in task manager.
 */
public class RedoCommand extends Command {

    public static final String COMMAND_WORD = "REDO";
    public static final String MESSAGE_SUCCESS = "Previous action has been redone.";
    public static final String MESSAGE_FAILURE = "Nothing to redo.";

    @Override
    public CommandResult execute() throws CommandException {
        assert model != null;
        try {
            model.redoTaskManager();
            return new CommandResult(MESSAGE_SUCCESS);
        } catch (EmptyStackException ese) {
            throw new CommandException(MESSAGE_FAILURE);
        }
    }
}
```
###### \java\seedu\taskmanager\logic\commands\UndoCommand.java
``` java
/**
 * Undo the previous action in task manager.
 */
public class UndoCommand extends Command {

    public static final String COMMAND_WORD = "UNDO";
    public static final String MESSAGE_SUCCESS = "Previous action has been undone.";
    public static final String MESSAGE_FAILURE = "Nothing to undo.";

    @Override
    public CommandResult execute() throws CommandException {
        assert model != null;
        try {
            model.undoTaskManager();
            return new CommandResult(MESSAGE_SUCCESS);
        } catch (EmptyStackException ese) {
            throw new CommandException(MESSAGE_FAILURE);
        }
    }
}
```
###### \java\seedu\taskmanager\logic\commands\UpdateCommand.java
``` java
/**
 * Updates the details of an existing task in the task manager.
 */
public class UpdateCommand extends Command {

    public static final String COMMAND_WORD = "UPDATE";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Updates the details of the task identified "
            + "by the index number used in the last task listing. "
            + "Existing values will be overwritten by the input values.\n"
            + "Parameters: INDEX (must be a positive integer) [TASK] ON [DATE] FROM [STARTTIME] TO [ENDTIME]\n"
            + "Example: " + COMMAND_WORD + " 1 ON 04/03/17 FROM 1630 TO 1830";

    public static final String MESSAGE_UPDATE_TASK_SUCCESS = "Updated Task: %1$s";
    public static final String MESSAGE_NOT_UPDATED = "At least one field to edit must be provided.";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the task manager.";
    public static final String EMPTY_FIELD = "EMPTY_FIELD";

    private final int filteredTaskListIndex;
    private UpdateTaskDescriptor updateTaskDescriptor;
    private final Boolean isUpdateToDeadlineTask;

    /**
     * @param filteredTaskListIndex
     *            the index of the task in the filtered task list to update
     * @param updateTaskDescriptor
     *            details to update the task with
     */
    public UpdateCommand(int filteredTaskListIndex, UpdateTaskDescriptor updateTaskDescriptor,
            Boolean isUpdateToDeadlineTask) {
        assert filteredTaskListIndex > 0;
        assert updateTaskDescriptor != null;

        // converts filteredTaskListIndex from one-based to zero-based.
        this.filteredTaskListIndex = filteredTaskListIndex - 1;

        this.updateTaskDescriptor = new UpdateTaskDescriptor(updateTaskDescriptor);

        this.isUpdateToDeadlineTask = isUpdateToDeadlineTask;
    }

    @Override
    public CommandResult execute() throws CommandException {
        // UpdateTaskDescriptor newUpdateTaskDescriptor = new
        // UpdateTaskDescriptor();

        List<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (filteredTaskListIndex >= lastShownList.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToUpdate = lastShownList.get(filteredTaskListIndex);

        if (!isUpdateToDeadlineTask) {
            if ((isOnlyStartUpdated() || isOnlyEndUpdated()) && isToUpdateFloatingTask(taskToUpdate)) {
                throw new CommandException(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, MESSAGE_USAGE));
            } else {
                if (isOnlyStartUpdated()) {
                    updateTaskDescriptor.setEndDate(Optional.of(taskToUpdate.getEndDate()));
                    updateTaskDescriptor.setEndTime(Optional.of(taskToUpdate.getEndTime()));
                } else {
                    if (isOnlyEndUpdated()) {
                        updateTaskDescriptor.setStartDate(Optional.of(taskToUpdate.getStartDate()));
                        updateTaskDescriptor.setStartTime(Optional.of(taskToUpdate.getStartTime()));
                    }
                }
            }
            if ((isOnlyStartTimeUpdated() || isOnlyEndTimeUpdated())
                    && (isToUpdateFloatingTask(taskToUpdate) || isDeadlineTaskToUpdate(taskToUpdate))) {
                throw new CommandException(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, MESSAGE_USAGE));
            } else {
                if (isOnlyEndTimeUpdated()) {
                    updateTaskDescriptor.setStartTime(Optional.of(taskToUpdate.getStartTime()));
                    updateTaskDescriptor.setStartDate(Optional.of(taskToUpdate.getStartDate()));
                    updateTaskDescriptor.setEndDate(Optional.of(taskToUpdate.getEndDate()));
                } else {
                    if (isOnlyStartTimeUpdated()) {
                        updateTaskDescriptor.setEndTime(Optional.of(taskToUpdate.getEndTime()));
                        updateTaskDescriptor.setStartDate(Optional.of(taskToUpdate.getStartDate()));
                        updateTaskDescriptor.setEndDate(Optional.of(taskToUpdate.getEndDate()));
                    }
                }
            }
        }

        if (isOnlyCategoriesUpdate() || isOnlyTaskNameUpdated()) {
            updateTaskDescriptor.setStartDate(Optional.of(taskToUpdate.getStartDate()));
            updateTaskDescriptor.setStartTime(Optional.of(taskToUpdate.getStartTime()));
            updateTaskDescriptor.setEndDate(Optional.of(taskToUpdate.getEndDate()));
            updateTaskDescriptor.setEndTime(Optional.of(taskToUpdate.getEndTime()));
        }

        Task updatedTask = createUpdatedTask(taskToUpdate, updateTaskDescriptor);

        try {
            model.updateTask(filteredTaskListIndex, updatedTask);
        } catch (UniqueTaskList.DuplicateTaskException dpe) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        }

        model.updateFilteredListToShowAll();
        return new CommandResult(String.format(MESSAGE_UPDATE_TASK_SUCCESS, taskToUpdate));
    }

    /**
     * Checks if only the task name field has been identified by user to be
     * updated To ensure that other task details like startTime startDate
     * endTime endDate are not lost
     *
     * @return true if only task name has been identified by user to be updated
     */
    private boolean isOnlyTaskNameUpdated() {
        if (updateTaskDescriptor.getStartDate().get().toString().equals(EMPTY_FIELD)
                && updateTaskDescriptor.getStartTime().get().toString().equals(EMPTY_FIELD)
                && updateTaskDescriptor.getEndDate().get().toString().equals(EMPTY_FIELD)
                && updateTaskDescriptor.getEndTime().get().toString().equals(EMPTY_FIELD)
                && updateTaskDescriptor.getTaskName().isPresent()) {
            return true;
        } else {
            return false;
        }
    }

    /**
     * Checks if only the category field has been identified by user to be
     * updated To ensure that other task details like startTime startDate
     * endTime endDate are not lost
     *
     * @return true if only categories are identified by user to be updated
     */
    private boolean isOnlyCategoriesUpdate() {
        if (updateTaskDescriptor.getStartDate().get().toString().equals(EMPTY_FIELD)
                && updateTaskDescriptor.getStartTime().get().toString().equals(EMPTY_FIELD)
                && updateTaskDescriptor.getEndDate().get().toString().equals(EMPTY_FIELD)
                && updateTaskDescriptor.getEndTime().get().toString().equals(EMPTY_FIELD)
                && updateTaskDescriptor.getCategories().isPresent()) {
            return true;
        } else {
            return false;
        }
    }

    private boolean isDeadlineTaskToUpdate(ReadOnlyTask taskToUpdate) {
        if (taskToUpdate.getStartDate().value.equals(EMPTY_FIELD)
                && taskToUpdate.getStartTime().value.equals(EMPTY_FIELD)
                && !taskToUpdate.getEndDate().value.equals(EMPTY_FIELD)
                && !taskToUpdate.getEndTime().value.equals(EMPTY_FIELD)) {
            return true;
        } else {
            return false;
        }
    }

    private boolean isOnlyStartTimeUpdated() {
        if (updateTaskDescriptor.getStartDate().get().toString().equals(EMPTY_FIELD)
                && !updateTaskDescriptor.getStartTime().get().toString().equals(EMPTY_FIELD)
                && updateTaskDescriptor.getEndDate().get().toString().equals(EMPTY_FIELD)
                && updateTaskDescriptor.getEndTime().get().toString().equals(EMPTY_FIELD)) {
            return true;
        } else {
            return false;
        }
    }

    private boolean isOnlyEndTimeUpdated() {
        if (updateTaskDescriptor.getStartDate().get().toString().equals(EMPTY_FIELD)
                && updateTaskDescriptor.getStartTime().get().toString().equals(EMPTY_FIELD)
                && updateTaskDescriptor.getEndDate().get().toString().equals(EMPTY_FIELD)
                && !updateTaskDescriptor.getEndTime().get().toString().equals(EMPTY_FIELD)) {
            return true;
        } else {
            return false;
        }
    }

    private boolean isToUpdateFloatingTask(ReadOnlyTask taskToUpdate) {
        if (taskToUpdate.getStartDate().value.equals(EMPTY_FIELD)
                && taskToUpdate.getStartTime().value.equals(EMPTY_FIELD)
                && taskToUpdate.getEndDate().value.equals(EMPTY_FIELD)
                && taskToUpdate.getEndTime().value.equals(EMPTY_FIELD)) {
            return true;
        } else {
            return false;
        }
    }

    private boolean isOnlyStartUpdated() {
        if (!updateTaskDescriptor.getStartDate().get().toString().equals(EMPTY_FIELD)
                && !updateTaskDescriptor.getStartTime().get().toString().equals(EMPTY_FIELD)
                && updateTaskDescriptor.getEndDate().get().toString().equals(EMPTY_FIELD)
                && updateTaskDescriptor.getEndTime().get().toString().equals(EMPTY_FIELD)) {
            return true;
        } else {
            return false;
        }
    }

    private boolean isOnlyEndUpdated() {
        if (updateTaskDescriptor.getStartDate().get().toString().equals(EMPTY_FIELD)
                && updateTaskDescriptor.getStartTime().get().toString().equals(EMPTY_FIELD)
                && !updateTaskDescriptor.getEndDate().get().toString().equals(EMPTY_FIELD)
                && !updateTaskDescriptor.getEndTime().get().toString().equals(EMPTY_FIELD)) {
            return true;
        } else {
            return false;
        }
    }

    /**
     * Creates and returns a {@code Task} with the details of {@code taskToEdit}
     * edited with {@code editTaskDescriptor}.
     */
    private static Task createUpdatedTask(ReadOnlyTask taskToUpdate, UpdateTaskDescriptor updateTaskDescriptor) {
        assert taskToUpdate != null;

        TaskName updatedTaskName = updateTaskDescriptor.getTaskName().orElseGet(taskToUpdate::getTaskName);
        StartDate updatedStartDate = updateTaskDescriptor.getStartDate().orElseGet(taskToUpdate::getStartDate);
        StartTime updatedStartTime = updateTaskDescriptor.getStartTime().orElseGet(taskToUpdate::getStartTime);
        EndDate updatedEndDate = updateTaskDescriptor.getEndDate().orElseGet(taskToUpdate::getEndDate);
        EndTime updatedEndTime = updateTaskDescriptor.getEndTime().orElseGet(taskToUpdate::getEndTime);
        UniqueCategoryList updatedCategories = updateTaskDescriptor.getCategories()
                .orElseGet(taskToUpdate::getCategories);

        return new Task(updatedTaskName, updatedStartDate, updatedStartTime, updatedEndDate, updatedEndTime, false,
                updatedCategories);
    }

    /**
     * Stores the details to edit the task with. Each non-empty field value will
     * replace the corresponding field value of the task.
     */
    public static class UpdateTaskDescriptor {
        private Optional<TaskName> taskname = Optional.empty();
        private Optional<StartDate> startDate = Optional.empty();
        private Optional<StartTime> startTime = Optional.empty();
        private Optional<EndDate> endDate = Optional.empty();
        private Optional<EndTime> endTime = Optional.empty();
        private Optional<UniqueCategoryList> categories = Optional.empty();

        public UpdateTaskDescriptor() {
        }

        public UpdateTaskDescriptor(UpdateTaskDescriptor toCopy) {
            this.taskname = toCopy.getTaskName();
            this.startDate = toCopy.getStartDate();
            this.startTime = toCopy.getStartTime();
            this.endDate = toCopy.getEndDate();
            this.endTime = toCopy.getEndTime();
            this.categories = toCopy.getCategories();
        }

        /**
         * Returns true if at least one field is updated.
         */
        public boolean isAnyFieldUpdated() {
            return CollectionUtil.isAnyPresent(this.taskname, this.startDate, this.startTime, this.endDate,
                    this.endTime, this.categories);
        }

        public void setTaskName(Optional<TaskName> taskname) {
            assert taskname != null;
            this.taskname = taskname;
        }

        public Optional<TaskName> getTaskName() {
            return taskname;
        }

        public void setStartDate(Optional<StartDate> startDate) {
            assert startDate != null;
            this.startDate = startDate;
        }

        public Optional<StartDate> getStartDate() {
            return startDate;
        }

        public void setStartTime(Optional<StartTime> startTime) {
            assert startTime != null;
            this.startTime = startTime;
        }

        public Optional<StartTime> getStartTime() {
            return startTime;
        }

        public void setEndDate(Optional<EndDate> endDate) {
            assert endDate != null;
            this.endDate = endDate;
        }

        public Optional<EndDate> getEndDate() {
            return endDate;
        }

        public void setEndTime(Optional<EndTime> endTime) {
            assert endTime != null;
            this.endTime = endTime;
        }

        public Optional<EndTime> getEndTime() {
            return endTime;
        }

        public void setCategories(Optional<UniqueCategoryList> categories) {
            assert categories != null;
            this.categories = categories;
        }

        public Optional<UniqueCategoryList> getCategories() {
            return categories;
        }

    }
}
```
###### \java\seedu\taskmanager\logic\parser\ChangeSaveLocationCommandParser.java
``` java
public class ChangeSaveLocationCommandParser {

    public static final String INVALID_SAVE_LOCATION = "Invalid input for save location";

    /**
     * Parses the given {@code String} of arguments in the context of the
     * ChangeSaveLocationCommand and returns an ChangeSaveLocationCommand object
     * for execution.
     */

    public Command parse(String args) {

        // assert args != null;

        String stringSaveLocation = args;
        File checkLocation = new File(args.trim());

        if (("".equals(stringSaveLocation))) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, ChangeSaveLocationCommand.MESSAGE_USAGE));
        }
        if (!checkLocation.exists()) {
            return new IncorrectCommand(String.format(ChangeSaveLocationCommand.MESSAGE_USAGE, INVALID_SAVE_LOCATION));
        }

        if (!(stringSaveLocation.substring(stringSaveLocation.length() - 1).equals("/"))) {
            stringSaveLocation += "/";
        }

        stringSaveLocation += "taskmanager.xml";
        File saveLocation = new File(stringSaveLocation.trim());

        return new ChangeSaveLocationCommand(saveLocation);
    }

}
```
###### \java\seedu\taskmanager\logic\parser\DeleteCommandParser.java
``` java
/**
 * Parses input arguments and creates a new DeleteCommand object
 */
public class DeleteCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the
     * DeleteCommand and returns an DeleteCommand object for execution.
     */
    public Command parse(String args) {
        assert args != null;

        if (args.trim().matches(DeleteCommand.DELETE_COMMAND_VALIDATION_REGEX_1)) {
            Optional<Integer> index = ParserUtil.parseIndex(args);
            if (!index.isPresent()) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
            }
            return new DeleteCommand(index.get());
        } else {
            if (args.isEmpty()) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
            }
            return new DeleteCommand(args.trim());
        }
    }
}
```
###### \java\seedu\taskmanager\logic\parser\UpdateCommandParser.java
``` java
/**
 * Parses input arguments and creates a new UpdateCommand object
 */
public class UpdateCommandParser {

    public static final String EMPTY_FIELD = "EMPTY_FIELD";
    public static final String INVALID_TIME = "Invalid input for time\nTime must be between 0000 and 2359";

    /**
     * Parses the given {@code String} of arguments in the context of the
     * EditCommand and returns an EditCommand object for execution.
     */
    public Command parse(String args) {
        assert args != null;
        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(PREFIX_ON, PREFIX_BY, PREFIX_FROM, PREFIX_TO,
                PREFIX_CATEGORY);
        argsTokenizer.tokenize(args);
        List<Optional<String>> preambleFields = ParserUtil.splitPreamble(argsTokenizer.getPreamble().orElse(""), 2);

        Optional<Integer> index = preambleFields.get(0).flatMap(ParserUtil::parseIndex);
        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UpdateCommand.MESSAGE_USAGE));
        }

        UpdateTaskDescriptor updateTaskDescriptor = new UpdateTaskDescriptor();

        Boolean isUpdateToDeadlineTask = false;

        try {
            Optional<String> taskName = preambleFields.get(1);
            Optional<String> onPrefixInput = argsTokenizer.getValue(PREFIX_ON);
            Optional<String> byPrefixInput = argsTokenizer.getValue(PREFIX_BY);
            Optional<String> fromPrefixInput = argsTokenizer.getValue(PREFIX_FROM);
            Optional<String> toPrefixInput = argsTokenizer.getValue(PREFIX_TO);

            /*
             * Checks to ensure correct combinations of arguments are added by
             * user when adding tasks to the task manager
             */
            if (!onPrefixInput.isPresent() || !byPrefixInput.isPresent() || !fromPrefixInput.isPresent()
                    || !toPrefixInput.isPresent()) {
                if ((onPrefixInput.isPresent()) && ((byPrefixInput.isPresent()) || (fromPrefixInput.isPresent()))) {
                    throw new NoSuchElementException("");
                }
                if ((byPrefixInput.isPresent()) && ((onPrefixInput.isPresent()) || (fromPrefixInput.isPresent())
                        || (toPrefixInput.isPresent()))) {
                    throw new NoSuchElementException("");
                }
                if (((fromPrefixInput.isPresent()) && ((onPrefixInput.isPresent()) || (byPrefixInput.isPresent())))) {
                    throw new NoSuchElementException("");
                }
            }

            if (byPrefixInput.isPresent()) {
                isUpdateToDeadlineTask = true;
            }

            String stringStartDate = "";
            String stringStartTime = "";
            String stringEndTime = "";
            String stringEndDate = "";

            if (fromPrefixInput.isPresent() && fromPrefixInput.get().matches("\\d+")) {
                if (isValidTime(fromPrefixInput.get())) {
                    stringStartTime = fromPrefixInput.get();
                }
            } else {
                if (onPrefixInput.isPresent() && onPrefixInput.get().matches("\\d+")) {
                    if (isValidTime(onPrefixInput.get())) {
                        stringStartTime = onPrefixInput.get();
                    }
                }
            }
            if (toPrefixInput.isPresent() && toPrefixInput.get().matches("\\d+")) {
                if (isValidTime(toPrefixInput.get())) {
                    stringEndTime = toPrefixInput.get();
                }
            }

            /*
             * To parse date input if required and throws exceptions if
             * incorrect arguments of date are included
             */
            if (onPrefixInput.isPresent()) {
                String[] splited = onPrefixInput.get().split("\\s+");
                stringStartDate = splited[0];
                stringEndDate = splited[0];
                try {
                    stringStartTime = splited[1];
                    if (!isValidTime(stringStartTime)) {
                        throw new IllegalValueException(INVALID_TIME);
                    }
                    if (!toPrefixInput.isPresent()) {
                        stringEndTime = Integer.toString(100 + Integer.parseInt(splited[1]));
                    } else {
                        String[] splitedEndTime = toPrefixInput.get().split("\\s+");
                        try {
                            if (!(splitedEndTime[1].isEmpty())) {
                                throw new IllegalValueException("Incorrect input after TO prefix.\n"
                                        + "Example of Allowed Format: ADD task ON thursday 1200 TO 1400\n"
                                        + "Type HELP for user guide with detailed explanations of all commands");
                            }
                        } catch (ArrayIndexOutOfBoundsException aioobe) {
                            stringEndTime = splitedEndTime[0];
                            if (!isValidTime(stringEndTime)) {
                                throw new IllegalValueException(INVALID_TIME);
                            }
                        }
                    }
                } catch (ArrayIndexOutOfBoundsException aioobe) {
                    stringStartTime = "0000";
                    if (("").equals(stringEndTime)) {
                        stringEndTime = "2359";
                    } else {
                        String[] splitedEndTime = toPrefixInput.get().split("\\s+");
                        try {
                            if (!(splitedEndTime[1].isEmpty())) {
                                throw new IllegalValueException("Incorrect input after TO prefix.\n"
                                        + "Example of Allowed Format: ADD task ON thursday 1200 TO 1400\n"
                                        + "Type HELP for user guide with detailed explanations of all commands");
                            }
                        } catch (ArrayIndexOutOfBoundsException aiobe) {
                            stringEndTime = splitedEndTime[0];
                            if (!isValidTime(stringEndTime)) {
                                throw new IllegalValueException(INVALID_TIME);
                            }
                        }
                    }
                }
                try {
                    if (!(splited[2].isEmpty())) {
                        throw new NoSuchElementException("");
                    }
                } catch (ArrayIndexOutOfBoundsException aioobe) {
                }
                if (Integer.parseInt(stringStartTime) > Integer.parseInt(stringEndTime)) {
                    throw new IllegalValueException(
                            "Invalid input of time, start time has to be earlier than end time");
                }
            }

            if (fromPrefixInput.isPresent()) {
                if (fromPrefixInput.get().trim().matches("[a-zA-Z]+")) {
                    stringStartDate = CurrentDate.getNewDate(fromPrefixInput.get());
                    stringStartTime = "0000";
                }
            }

            if (toPrefixInput.isPresent()) {
                if (toPrefixInput.get().trim().matches("[a-zA-Z]+")) {
                    stringEndDate = CurrentDate.getNewDate(toPrefixInput.get());
                    stringEndTime = "2359";
                }
            }

            if ((fromPrefixInput.isPresent()) && (!fromPrefixInput.get().matches("\\d+"))) {
                String[] splited = fromPrefixInput.get().split("\\s+");
                try {
                    if (splited[0].matches(STARTDATE_VALIDATION_REGEX2)) {
                        splited[0] = CurrentDate.getNewDate(splited[0]);
                    }
                    stringStartDate = splited[0];
                    stringStartTime = splited[1];
                } catch (ArrayIndexOutOfBoundsException aioobe) {
                    if (splited[0].matches(STARTDATE_VALIDATION_REGEX2)) {
                        stringStartDate = CurrentDate.getNewDate(splited[0]);
                    }
                }
            }

            if ((toPrefixInput.isPresent()) && (!toPrefixInput.get().matches("\\d+"))) {
                String[] splited = toPrefixInput.get().split("\\s+");
                try {
                    if (splited[0].matches(STARTDATE_VALIDATION_REGEX2)) {
                        splited[0] = CurrentDate.getNewDate(splited[0]);
                    }
                    stringEndDate = splited[0];
                    stringEndTime = splited[1];
                } catch (ArrayIndexOutOfBoundsException aioobe) {
                    if (splited[0].matches(STARTDATE_VALIDATION_REGEX2)) {
                        stringEndDate = CurrentDate.getNewDate(splited[0]);
                    }
                }
            }

            /*
             * To parse deadline input if required and throws exceptions if
             * incorrect arguments of deadline are included
             */
            if (byPrefixInput.isPresent()) {
                String[] splited = byPrefixInput.get().trim().split("\\s+");
                stringEndDate = splited[0];
                try {
                    stringEndTime = splited[1];
                    if (!isValidTime(stringEndTime)) {
                        throw new IllegalValueException(INVALID_TIME);
                    }
                } catch (ArrayIndexOutOfBoundsException aioobe) {
                    stringEndTime = "2359";
                } catch (NumberFormatException nfe) {
                    return new IncorrectCommand("Invalid input after prefix BY\n"
                            + "Example of Allowed Format: ADD project meeting BY thursday 1400 \n"
                            + "Type HELP for user guide with detailed explanations of all commands");
                }
                try {
                    if (!(splited[2].isEmpty())) {
                        throw new NoSuchElementException("");
                    }
                } catch (ArrayIndexOutOfBoundsException aioobe) {
                }
            }

            Optional<String> startDate;
            Optional<String> startTime;
            Optional<String> endDate;
            Optional<String> endTime;

            if (!("").equals(stringStartTime)) {
                startTime = Optional.of(stringStartTime);
            } else {
                startTime = Optional.of(EMPTY_FIELD);
            }
            if (!("").equals(stringEndTime)) {
                endTime = Optional.of(stringEndTime);
            } else {
                endTime = Optional.of(EMPTY_FIELD);
            }
            if (!("").equals(stringStartDate)) {
                startDate = Optional.of(stringStartDate);
            } else {
                startDate = Optional.of(EMPTY_FIELD);
            }
            if (!("").equals(stringEndDate)) {
                endDate = Optional.of(stringEndDate);
            } else {
                endDate = Optional.of(EMPTY_FIELD);
            }

            if (startDate.isPresent()) {
                if (startDate.get().matches(STARTDATE_VALIDATION_REGEX2)) {
                    startDate = Optional.of(CurrentDate.getNewDate(startDate.get()));
                }
            }
            if (endDate.isPresent()) {
                if (endDate.get().matches(STARTDATE_VALIDATION_REGEX2)) {
                    endDate = Optional.of(CurrentDate.getNewDate(endDate.get()));
                }
            }

            updateTaskDescriptor.setTaskName(ParserUtil.parseTaskName(taskName));
            updateTaskDescriptor.setStartDate(ParserUtil.parseStartDate(startDate));
            updateTaskDescriptor.setStartTime(ParserUtil.parseStartTime(startTime));
            updateTaskDescriptor.setEndDate(ParserUtil.parseEndDate(endDate));
            updateTaskDescriptor.setEndTime(ParserUtil.parseEndTime(endTime));
            updateTaskDescriptor.setCategories(
                    parseCategoriesForUpdate(ParserUtil.toSet(argsTokenizer.getAllValues(PREFIX_CATEGORY))));

        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        } catch (NoSuchElementException nsee) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UpdateCommand.MESSAGE_USAGE));
        } catch (ArrayIndexOutOfBoundsException aioobe) {
            return new IncorrectCommand(
                    "Invalid command input!\nExample of Allowed Format: ADD e-mail John BY thursday 1400\n"
                            + "Type HELP for user guide with detailed explanations of all commands");
        } catch (NumberFormatException nfe) {
            return new IncorrectCommand("Invalid input after prefix TO, only input of time is allowed\n"
                    + "Example of Allowed Format: ADD project meeting ON thursday 1400 TO 1800\n"
                    + "Type HELP for user guide with detailed explanations of all commands");
        }

        if (!updateTaskDescriptor.isAnyFieldUpdated()) {
            return new IncorrectCommand(UpdateCommand.MESSAGE_NOT_UPDATED);
        }
        return new UpdateCommand(index.get(), updateTaskDescriptor, isUpdateToDeadlineTask);
    }

    private boolean isValidTime(String string) {
        if (Integer.parseInt(string) >= 2400 || Integer.parseInt(string.substring(string.length() - 2)) >= 60) {
            return false;
        } else {
            return true;
        }
    }

    /**
     * Parses {@code Collection<String> tags} into an
     * {@code Optional<UniqueTagList>} if {@code tags} is non-empty. If
     * {@code tags} contain only one element which is an empty string, it will
     * be parsed into a {@code Optional<UniqueTagList>} containing zero tags.
     */

    private Optional<UniqueCategoryList> parseCategoriesForUpdate(Collection<String> categories)
            throws IllegalValueException {
        assert categories != null;

        if (categories.isEmpty()) {
            return Optional.empty();
        }
        Collection<String> categorySet = categories.size() == 1 && categories.contains("") ? Collections.emptySet()
                : categories;
        return Optional.of(ParserUtil.parseCategories(categorySet));
    }

}
```
###### \java\seedu\taskmanager\model\category\UniqueCategoryList.java
``` java
    /**
     * Checks if task is assigned any category
     * @return true if category list is empty.
     */
    public boolean isEmptyCategoryList() {
        if (internalList.isEmpty()) {
            return true;
        } else {
            return false;
        }
    }

}
```
###### \java\seedu\taskmanager\model\Model.java
``` java
    /**
     * Deletes tasks by their date. Returns the number of tasks deleted.
     */
    int deleteTasksDate(UnmodifiableObservableList<ReadOnlyTask> targets) throws UniqueTaskList.TaskNotFoundException;

    /**
     * Deletes the task by its name. Returns the number of tasks deleted.
     */
    int deleteTasksName(UnmodifiableObservableList<ReadOnlyTask> targets, String toDeleteTaskName)
            throws UniqueTaskList.TaskNotFoundException;

```
###### \java\seedu\taskmanager\model\ModelManager.java
``` java
    /** Re-save data when save location has changed */
    public void saveTaskManager() {
        indicateTaskManagerChanged();
    }

    /** Save a copy of task manager before data is changed. */
    private void saveInstance() {
        undoTaskManager.push(new TaskManager(taskManager));
        redoTaskManager.clear();
    }

    /** Undo previous action of task manager. */
    public void undoTaskManager() {
        TaskManager currentTaskManager = new TaskManager(taskManager);
        taskManager.resetData(undoTaskManager.peek());
        undoTaskManager.pop();
        redoTaskManager.push(currentTaskManager);
    }

    /** Undo previous action of task manager. */
    public void redoTaskManager() {
        TaskManager currentTaskManager = new TaskManager(taskManager);
        taskManager.resetData(redoTaskManager.peek());
        redoTaskManager.pop();
        undoTaskManager.push(currentTaskManager);
    }

```
###### \java\seedu\taskmanager\model\ModelManager.java
``` java
    /**
     * Deletes tasks by their date. Returns the number of tasks deleted.
     */
    @Override
    public synchronized int deleteTasksDate(UnmodifiableObservableList<ReadOnlyTask> targets)
            throws TaskNotFoundException {
        int numDeletedTasks = 0;
        saveInstance();
        while (targets.size() != 0) {
            try {
                ReadOnlyTask taskToDelete = targets.get(0);
                saveInstance();
                taskManager.removeTask(taskToDelete);
                numDeletedTasks++;
            } catch (TaskNotFoundException pnfe) {
                assert false : "The target task cannot be missing";
            }
        }
        updateFilteredListToShowAll();
        indicateTaskManagerChanged();
        return numDeletedTasks;
    }

    /**
     * Deletes the task by its name. Returns the number of tasks deleted.
     */
    @Override
    public synchronized int deleteTasksName(UnmodifiableObservableList<ReadOnlyTask> targets, String toDeleteTaskName)
            throws TaskNotFoundException {
        int numDeletedTasks = 0;
        saveInstance();
        for (int index = 0; targets.size() != index; index++) {
            try {
                ReadOnlyTask taskToDelete = targets.get(index);
                if (toDeleteTaskName.equals(taskToDelete.getTaskName().fullTaskName)) {
                    taskManager.removeTask(taskToDelete);
                    index--;
                    numDeletedTasks++;
                }
            } catch (TaskNotFoundException pnfe) {
                assert false : "The target task cannot be missing";
            }
        }
        updateFilteredListToShowAll();
        indicateTaskManagerChanged();
        return numDeletedTasks;
    }

```
###### \java\seedu\taskmanager\model\task\ReadOnlyTask.java
``` java
    /**
     * Formats the task as text, showing all contact details.
     */
    default String getAsText() {
        final StringBuilder builder = new StringBuilder();
        builder.append(getTaskName());

        if (!getStartDate().toString().equals("EMPTY_FIELD")) {
            builder.append(" Start Date: ").append(getStartDate());
        }

        if (!getStartTime().toString().equals("EMPTY_FIELD")) {
            builder.append(" Start Time: ").append(getStartTime());
        }

        if (!getEndDate().toString().equals("EMPTY_FIELD")) {
            builder.append(" End Date: ").append(getEndDate());
        }

        if (!getEndTime().toString().equals("EMPTY_FIELD")) {
            builder.append(" End Time: ").append(getEndTime());
        }

        if (!getCategories().isEmptyCategoryList()) {
            builder.append(" Categories: ");
            getCategories().forEach(builder::append);
        }

        return builder.toString();
    }
}
```
###### \java\seedu\taskmanager\ui\TaskCard.java
``` java
public class TaskCard extends UiPart<Region> {

    private static final String FXML = "TaskCard.fxml";

    @FXML
    private HBox cardPane;
    @FXML
    private Label taskname;
    @FXML
    private Label id;
    @FXML
    private ListView<ListView<Label>> detailsList;
    private ObservableList<ListView<Label>> listRows = FXCollections.observableArrayList();
    private ObservableList<Label> topLabels = FXCollections.observableArrayList();
    private ObservableList<Label> botLabels = FXCollections.observableArrayList();
    private ListView<Label> topRow = new ListView<Label>();
    private ListView<Label> botRow = new ListView<Label>();
    @FXML
    private Label markedCompleted;
    @FXML
    private FlowPane categories;

    private final StringProperty empty = new SimpleStringProperty("");
    private final StringProperty completed = new SimpleStringProperty("Completed");

    public TaskCard(ReadOnlyTask task, int displayedIndex) {
        super(FXML);
        taskname.setText(task.getTaskName().fullTaskName);
        id.setText(displayedIndex + ". ");

        if (isMultipleDateEvent(task)) {

            Label startDate = new Label();
            startDate.setText("Start Date: " + task.getStartDate().value + "   ");
            startDate.setStyle("-fx-font-size: 11px");
            topLabels.add(startDate);
            Label startTime = new Label();
            startTime.setText("Start Time: " + task.getStartTime().value);
            startTime.setStyle("-fx-font-size: 11px");
            topLabels.add(startTime);
            Label endDate = new Label();
            endDate.setText("End Date: " + task.getEndDate().value + "     ");
            endDate.setStyle("-fx-font-size: 11px");
            botLabels.add(endDate);
            Label endTime = new Label();
            endTime.setText("End Time: " + task.getEndTime().value);
            endTime.setStyle("-fx-font-size: 11px");
            botLabels.add(endTime);

            topRow.setItems(topLabels);
            botRow.setItems(botLabels);

            topRow.setOrientation(Orientation.HORIZONTAL);
            botRow.setOrientation(Orientation.HORIZONTAL);

            topRow.prefHeightProperty().bind(Bindings.size(topLabels).multiply(14));
            botRow.prefHeightProperty().bind(Bindings.size(botLabels).multiply(14));

            listRows.add(topRow);
            listRows.add(botRow);

            detailsList.setItems(listRows);
        }

        if (isSameDateEvent(task)) {
            Label date = new Label();
            date.setText("Date: " + task.getStartDate().value);
            date.setStyle("-fx-font-size: 11px");
            topLabels.add(date);
            Label startTime = new Label();
            startTime.setText("Start Time: " + task.getStartTime().value + "   ");
            startTime.setStyle("-fx-font-size: 11px");
            botLabels.add(startTime);
            Label endTime = new Label();
            endTime.setText("End Time: " + task.getEndTime().value);
            endTime.setStyle("-fx-font-size: 11px");
            botLabels.add(endTime);

            topRow.setItems(topLabels);
            botRow.setItems(botLabels);

            topRow.setOrientation(Orientation.HORIZONTAL);
            botRow.setOrientation(Orientation.HORIZONTAL);

            topRow.prefHeightProperty().bind(Bindings.size(topLabels).multiply(14));
            botRow.prefHeightProperty().bind(Bindings.size(botLabels).multiply(14));

            listRows.add(topRow);
            listRows.add(botRow);

            detailsList.setItems(listRows);
        }

        if (isDeadlineEvent(task)) {
            Label dueDate = new Label();
            dueDate.setText("Due by: " + task.getEndDate().value + "   ");
            dueDate.setStyle("-fx-font-size: 11px");
            topLabels.add(dueDate);
            Label dueTime = new Label();
            dueTime.setText(task.getEndTime().value);
            dueTime.setStyle("-fx-font-size: 11px");

            topLabels.add(dueTime);

            topRow.setItems(topLabels);

            topRow.setOrientation(Orientation.HORIZONTAL);

            topRow.prefHeightProperty().bind(Bindings.size(topLabels).multiply(14));

            listRows.add(topRow);

            detailsList.setItems(listRows);
        }

        if (task.getIsMarkedAsComplete()) {
            markedCompleted.textProperty().bind(completed);
        } else {
            markedCompleted.textProperty().bind(empty);
        }
        initCategory(task);
    }

    private boolean isMultipleDateEvent(ReadOnlyTask task) {
        if (!task.getStartDate().value.equals(task.getEndDate().value)
                && !task.getStartDate().value.equals("EMPTY_FIELD")) {
            return true;
        } else {
            return false;
        }
    }

    private boolean isDeadlineEvent(ReadOnlyTask task) {
        if (isStartDateEmpty(task) && isStartTimeEmpty(task) && !isEndDateEmpty(task) && !isEndTimeEmpty(task)) {
            return true;
        } else {
            return false;
        }
    }

    private boolean isStartDateEmpty(ReadOnlyTask task) {
        if ((task.getStartDate().value).equals("EMPTY_FIELD")) {
            return true;
        } else {
            return false;
        }
    }

    private boolean isStartTimeEmpty(ReadOnlyTask task) {
        if ((task.getStartTime().value).equals("EMPTY_FIELD")) {
            return true;
        } else {
            return false;
        }
    }

    private boolean isEndDateEmpty(ReadOnlyTask task) {
        if ((task.getEndDate().value).equals("EMPTY_FIELD")) {
            return true;
        } else {
            return false;
        }
    }

    private boolean isEndTimeEmpty(ReadOnlyTask task) {
        if ((task.getEndTime().value).equals("EMPTY_FIELD")) {
            return true;
        } else {
            return false;
        }
    }

    private boolean isSameDateEvent(ReadOnlyTask task) {
        if ((task.getStartDate().value).equals(task.getEndDate().value)
                && (!task.getStartDate().value.equals("EMPTY_FIELD"))) {
            return true;
        } else {
            return false;
        }
    }

    private void initCategory(ReadOnlyTask task) {
        task.getCategories().forEach(category -> categories.getChildren().add(new Label(category.categoryName)));
    }

}
```
